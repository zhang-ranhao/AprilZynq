/****************************************************************/
/*	apriltag.h													*/
/****************************************************************/
/*	Author: Ranhao zhang
	Copyright 2023(c) Space Mechatronics Laboratory,
  	School of Astronautics NUAA									*/
/****************************************************************/
/*  Description:
  		This file is the header file of apriltag.c
		 														*/
/****************************************************************/
/*  Revision History:
	6/5/2023(Ranhao): Created
																*/
/****************************************************************/

#ifndef __APRILTAG_H__
#define __APRILTAG_H__

/* ------------------------------------------------------------ */
/*				Include File Definitions						*/
/* ------------------------------------------------------------ */
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

#include "xil_types.h"
#include "xil_printf.h"

#include "..\common\image_u8.h"
#include "..\common\image_u8x4.h"
#include "..\common\zarray.h"
#include "..\common\timeprofile.h"
#include "..\common\matd.h"
#include "..\tag\tag36h11.h"


#include "..\..\..\Hardware\common\config.h"
#include "..\..\..\Hardware\Driver\pl_vdma.h"
#include "..\..\..\Hardware\Driver\ps_gpio.h"
#include "..\..\..\Hardware\Driver\ps_fs.h"
/* ------------------------------------------------------------ */
/*				Miscellaneous Declarations						*/
/* ------------------------------------------------------------ */
#define MAX_NENTRIES 65157
// Represents a tag family. Every tag belongs to a tag family. Tag
// families are generated by the Java tool
// april.tag.TagFamilyGenerator and can be converted to C using
// april.tag.TagToC.

struct quad
{
    float p[4][2]; // corners

    u8 reversed_border;

    // H: tag coordinates ([-1,1] at the black corners) to pixels
    // Hinv: pixels to tag
    matd_t *H, *Hinv;
};


struct apriltag_quad_thresh_params
{
    // reject quads containing too few pixels
    int min_cluster_pixels;

    // how many corner candidates to consider when segmenting a group
    // of pixels into a quad.
    int max_nmaxima;

    // Reject quads where pairs of edges have angles that are close to
    // straight or close to 180 degrees. Zero means that no quads are
    // rejected. (In radians).
    float critical_rad;
    float cos_critical_rad;

    // When fitting lines to the contours, what is the maximum mean
    // squared error allowed?  This is useful in rejecting contours
    // that are far from being quad shaped; rejecting these quads "early"
    // saves expensive decoding processing.
    float max_line_fit_mse;

    // When we build our model of black & white pixels, we add an
    // extra check that the white model must be (overall) brighter
    // than the black model.  How much brighter? (in pixel values,
    // [0,255]). .
    int min_white_black_diff;

    // should the thresholded image be deglitched? Only useful for
    // very noisy images
    int deglitch;
};


// Represents a detector object. Upon creating a detector, all fields
// are set to reasonable values, but can be overridden by accessing
// these fields.
typedef struct apriltag_detector apriltag_detector_t;
struct apriltag_detector
{
    ///////////////////////////////////////////////////////////////
    // User-configurable parameters.

    // How many threads should be used?
    //int nthreads;

    // detection of quads can be done on a lower-resolution image,
    // improving speed at a cost of pose accuracy and a slight
    // decrease in detection rate. Decoding the binary payload is
    // still done at full resolution. .
    float quad_decimate;

    // What Gaussian blur should be applied to the segmented image
    // (used for quad detection?)Parameter is the standard deviation
    // in pixels.  Very noisy images benefit from non-zero values
    // (e.g. 0.8).
    float quad_sigma;

    // When true, the edges of the each quad are adjusted to "snap
    // to" strong gradients nearby. This is useful when decimation is
    // employed, as it can increase the quality of the initial quad
    // estimate substantially. Generally recommended to be on (true).
    //
    // Very computationally inexpensive. Option is ignored if
    // quad_decimate = 1.
    u8 refine_edges;

    // How much sharpening should be done to decoded images? This
    // can help decode small tags but may or may not help in odd
    // lighting conditions or low light conditions.
    //
    // The default value is 0.25.
    double decode_sharpening;

    // When true, write a variety of debugging images to the
    // current working directory at various stages through the
    // detection process. (Somewhat slow).
    //u8 debug;

    struct apriltag_quad_thresh_params qtp;

    ///////////////////////////////////////////////////////////////
    // Statistics relating to last processed frame
    //timeprofile_t *tp;

    u32 nedges;
    u32 nsegments;
    u32 nquads;

    ///////////////////////////////////////////////////////////////
    // Internal variables below

    // Not freed on apriltag_destroy; a tag family can be shared
    // between multiple users. The user should ultimately destroy the
    // tag family passed into the constructor.
    apriltag_family_t *tag_family;

    // Used to manage multi-threading.
    //workerpool_t *wp;

    // Used for thread safety.
    //pthread_mutex_t mutex;
};

// Represents the detection of a tag. These are returned to the user
// and must be individually destroyed by the user.
typedef struct apriltag_detection apriltag_detection_t;
struct apriltag_detection
{
    // a pointer for convenience. not freed by apriltag_detection_destroy.
    apriltag_family_t *family;

    // The decoded ID of the tag
    int id;

    // How many error bits were corrected? Note: accepting large numbers of
    // corrected errors leads to greatly increased false positive rates.
    // NOTE: As of this implementation, the detector cannot detect tags with
    // a hamming distance greater than 2.
    int hamming;

    // A measure of the quality of the binary decoding process: the
    // average difference between the intensity of a data bit versus
    // the decision threshold. Higher numbers roughly indicate better
    // decodes. This is a reasonable measure of detection accuracy
    // only for very small tags-- not effective for larger tags (where
    // we could have sampled anywhere within a bit cell and still
    // gotten a good detection.)
    float decision_margin;

    // The 3x3 homography matrix describing the projection from an
    // "ideal" tag (with corners at (-1,1), (1,1), (1,-1), and (-1,
    // -1)) to pixels in the image. This matrix will be freed by
    // apriltag_detection_destroy.
    matd_t *H;

    // The center of the detection in image pixel coordinates.
    double c[2];

    // The corners of the tag in image pixel coordinates. These always
    // wrap counter-clockwise around the tag.
    double p[4][2];
};


struct quick_decode_entry
{
    u64 rcode;   // the queried code
    u16 id;      // the tag ID (a small integer)
    u8 hamming;  // how many errors corrected?
    u8 rotation; // number of rotations [0, 3]
};

struct quick_decode
{
    int nentries;//键值对的数目
    struct quick_decode_entry entries[MAX_NENTRIES];
};

typedef struct quick_decode quick_decode_t;
/* ------------------------------------------------------------ */
/*				Global Variables Declaraitons  					*/
/* ------------------------------------------------------------ */
extern apriltag_detector_t td;
extern quick_decode_t qd;
extern u8 apriltag_flag;
extern u8 debug_flag;
extern u8 quads_raw_buf[FRAME_SIZE];
/* ------------------------------------------------------------ */
/*				Procedure Declarations							*/
/* ------------------------------------------------------------ */
void apriltag_duty();
zarray_t * apriltag_detector_detect(apriltag_detector_t *td, image_u8_t *im_orig, timeprofile_t* tp);
void apriltag_detector_init(apriltag_detector_t *ptd, apriltag_family_t *ptf);
void quick_decode_init(apriltag_family_t *ptf, quick_decode_t *pqd, int maxhamming);
void quick_decode_add(quick_decode_t *pqd, u64 code, int id, int hamming);
image_u8_t *gray_to_u8_baseline();

#endif
